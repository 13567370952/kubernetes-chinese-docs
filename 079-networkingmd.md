# 网络

Kubernetes网络需要解决下面四类不同的问题：

1. 高耦合容器和容器间通信
2. Pod和Pod间通信
3. Pod和Service间通信
4. 外部和内部通信


## 模型和动机
Kubernetes从默认的Docker网络模型中脱离出来（尽管和Docker 1.8的网络插件已经很接近了）。在一个共享网络命名空间的平面内，目标是一个pod一个IP，每个pod都可以和其它物理机或者容器实现跨网络通信。每个pod一个IP创建了一个简洁的，后向兼容的模型，在这个模型里，无论从哪个角度来看，包括端口分配，组网，命名，服务发现，负载均衡，应用配置和迁移，pod都可以被当作虚拟机或者物理主机。


另一方面，动态端口分配，要求同时支持静态端口（如对外部可接入的服务）和动态分配的端口；需要对中心型分配和本地获取动态端口做区分，复杂的调度（应为端口是稀缺资源）对用户来说是非常不方便的；复杂的应用配置，造成用户会被端口冲突、重用和耗尽所困扰；要求非标准的方式来命名（如consul和etcd而不是DNS）；需要代理或者重定向才能让程序使用标准的命名和寻址技术（如web浏览器）；如果还希望监控整个组成员的变化，并且阻碍容器或pod迁移（使用CRIU），就需要监控和缓存无效的地址和端口变化。其它问题中，NAT分隔地址空间引入了额外的复杂度，打破了自注册机制。


## 容器到容器

所有容器在一个pod中表现为它们在同一个主机上并且不受网络限制。它们可以通过端口在本地实现互相通信。这提供了简单（已知静态端口），安全（端口绑定在localhost，可以被pod中其他容器发现但不会被外部看到），还有性能提升。这同样减少了物理机获虚拟机上非容器化应用的迁移。人们运行应用都堆砌到统一个主机上，它已经解决了如何让端口不冲突和已经安排了如何让客户端去找到它。

这个方法确实减少了一个pod中容器的隔离性（端口可能冲突），并且，可以没有容器私有化端口，但这些看起来都是未来才会面对的相对比较小的问题。另外，本地化pod是容器在pod中共享同样的资源（如volumes，cpu，内存等），所以希望并且可以容忍隔离性的减少。通常情况，用户可以控制哪些容器属于同一个pod，而不能控制哪些pod一起运行在一个主机上。




















































